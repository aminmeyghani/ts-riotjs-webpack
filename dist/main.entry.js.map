{"version":3,"sources":["webpack:///main.entry.js","webpack:///webpack/bootstrap 6040df2aeb5d9c708643","webpack:///./index.js","webpack:///../~/riot/riot.js","webpack:///./feature-x/riot.control.js","webpack:///../~/css-loader/lib/css-base.js","webpack:///../~/style-loader/addStyles.js","webpack:///./feature-x/components/entry/feat-x.ctrl.js","webpack:///./feature-x/components/entry/index.js","webpack:///./feature-x/components/messenger/index.js","webpack:///./feature-x/components/messenger/messenger.ctrl.js","webpack:///./feature-x/components/todo/index.js","webpack:///./feature-x/components/todo/todo.ctrl.js","webpack:///./feature-x/components/todo/todo.store.js","webpack:///./feature-x/components/widget/index.js","webpack:///./feature-x/components/widget/widget.ctrl.js","webpack:///./feature-x/index.js","webpack:///./feature-x/components/entry/feat-x.style.scss","webpack:///./feature-x/components/messenger/messenger.style.scss","webpack:///./feature-x/components/todo/todo.style.scss","webpack:///./feature-x/components/widget/widget.style.scss","webpack:///./feature-x/components/entry/feat-x.tpl.html","webpack:///./feature-x/components/messenger/messenger.tpl.html","webpack:///./feature-x/components/todo/todo.tpl.html","webpack:///./feature-x/components/widget/widget.tpl.html","webpack:///./feature-x/components/entry/feat-x.style.scss?37ad","webpack:///./feature-x/components/messenger/messenger.style.scss?c0c4","webpack:///./feature-x/components/todo/todo.style.scss?27b1","webpack:///./feature-x/components/widget/widget.style.scss?e8ac"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","window","undefined","loopKeys","expr","b0","brackets","els","slice","length","match","key","pos","val","mkitem","item","_each","dom","parent","remAttr","checksum","tagName","getTagName","template","outerHTML","hasImpl","tagImpl","impl","tmpl","root","parentNode","placeholder","document","createComment","tags","child","getTag","insertBefore","one","stub","removeChild","on","items","isArray","JSON","stringify","Object","keys","map","frag","createDocumentFragment","i","j","unmount","splice","_item","update","Tag","isLoop","cloneNode","innerHTML","mount","appendChild","walk","node","nodeType","_looped","_visited","setNamed","parseNamedElements","childTags","getAttribute","cachedTag","tag","ptag","push","parseExpressions","expressions","addExpr","extra","indexOf","extend","type","nodeValue","attr","each","attributes","name","bool","split","value","conf","updateOpts","ctx","self","el","opts","normalizeData","data","T_UNDEF","inheritFromParent","k","mustSync","propsInSyncWithParent","toggle","isMount","evt","loopDom","riot","observable","this","inherit","mkdom","cleanUpData","fn","toLowerCase","TAG_ATTRIBUTES","_tag","isMounted","attrs","a","kv","setAttribute","replace","_id","fastAbs","Date","getTime","Math","random","test","replaceYield","T_OBJECT","trigger","mixin","arguments","mix","T_STRING","isFunction","bind","init","firstChild","isInStub","keepRootTag","off","setEventHandler","handler","e","event","currentTarget","target","srcElement","which","charCode","keyCode","ignored","preventDefault","returnValue","preventUpdate","insertTo","before","attrName","toString","inStub","createTextNode","style","display","len","v","removeAttribute","nr","RIOT_TAG","namedTag","src","obj","args","o","blackList","checkie","ieVersion","matches","exec","rootTag","mkEl","optgroupInnerHTML","optionInnerHTML","tbodyInnerHTML","nextSibling","createElement","$$","selector","querySelectorAll","$","querySelector","Child","prototype","html","div","loops","opt","valRegx","selRegx","eachRegx","ifRegx","innerRegx","valuesMatch","selectedMatch","innerValue","eachMatch","ifMatch","labelRegx","elementRegx","tagRegx","labelMatch","elementMatch","tagMatch","innerContent","options","trim","innerOpt","injectStyle","css","styleNode","head","styleSheet","cssText","_rendered","body","rs","mountTo","_innerHTML","virtualDom","version","settings","Array","_ts","win","documentMode","callbacks","events","typed","cb","arr","apply","fns","busy","concat","all","mixins","hash","loc","href","parser","path","emit","current","location","started","r","route","arg","stop","removeEventListener","detachEvent","start","addEventListener","attachEvent","orig","cachedBrackets","b","re","x","s","RegExp","source","global","extract","Function","join","n","pair","_","wrap","nonull","reVars","str","substrings","parts","sub","open","close","level","cache","addRiotTags","list","selectAllTags","pushTags","allTags","nodeList","_el","util","_RiotControlApi","RiotControl","_stores","addStore","store","forEach","api","result","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","refs","addStyle","listToStyles","newStyles","media","sourceMap","part","createStyleElement","styleElement","getHeadElement","createLinkElement","linkElement","rel","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","applyToTag","newObj","index","replaceText","cssNode","childNodes","unescape","encodeURIComponent","blob","oldSrc","memoize","memo","isOldIE","navigator","userAgent","getElementsByTagName","newList","mayRemove","textStore","replacement","filter","Boolean","defineProperty","title","control","todoStore","_this","count","thing","send","message","msg","disabled","edit","text","add","input","done","TodoStore","todos","stuff","listen","d","bn","config","model","triggerName","broadcast","newTodo","pop","content","locals"],"mappings":"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","file":"main.entry.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/static/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/*\n\t  To compile manually:\n\t    1. webpack config:\n\t    plugins: [\n\t       new webpack.ProvidePlugin({\n\t         riot: 'riot/riot+compiler.js'\n\t       })\n\t     ]\n\t    2. in your index.js set `window.riot = riot`\n\t    3. riot.compile(require('./app/app.tpl'));\n\t    4. riot.compile(require('./app/app.tag'));\n\t*/\n\t\n\t__webpack_require__(14);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* Riot v2.2.2, @license MIT, (c) 2015 Muut Inc. + contributors */\n\t\n\t;(function(window, undefined) {\n\t  'use strict'\n\t  var riot = { version: 'v2.2.2', settings: {} }\n\t\n\t  // This globals 'const' helps code size reduction\n\t\n\t  // for typeof == '' comparisons\n\t  var T_STRING = 'string',\n\t      T_OBJECT = 'object',\n\t      T_UNDEF  = 'undefined'\n\t\n\t  // for IE8 and rest of the world\n\t  /* istanbul ignore next */\n\t  var isArray = Array.isArray || (function () {\n\t    var _ts = Object.prototype.toString\n\t    return function (v) { return _ts.call(v) === '[object Array]' }\n\t  })()\n\t\n\t  // Version# for IE 8-11, 0 for others\n\t  var ieVersion = (function (win) {\n\t    return (window && window.document || {}).documentMode | 0\n\t  })()\n\t\n\triot.observable = function(el) {\n\t\n\t  el = el || {}\n\t\n\t  var callbacks = {},\n\t      _id = 0\n\t\n\t  el.on = function(events, fn) {\n\t    if (isFunction(fn)) {\n\t      if (typeof fn.id === T_UNDEF) fn._id = _id++\n\t\n\t      events.replace(/\\S+/g, function(name, pos) {\n\t        (callbacks[name] = callbacks[name] || []).push(fn)\n\t        fn.typed = pos > 0\n\t      })\n\t    }\n\t    return el\n\t  }\n\t\n\t  el.off = function(events, fn) {\n\t    if (events == '*') callbacks = {}\n\t    else {\n\t      events.replace(/\\S+/g, function(name) {\n\t        if (fn) {\n\t          var arr = callbacks[name]\n\t          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n\t            if (cb._id == fn._id) arr.splice(i--, 1)\n\t          }\n\t        } else {\n\t          callbacks[name] = []\n\t        }\n\t      })\n\t    }\n\t    return el\n\t  }\n\t\n\t  // only single event supported\n\t  el.one = function(name, fn) {\n\t    function on() {\n\t      el.off(name, on)\n\t      fn.apply(el, arguments)\n\t    }\n\t    return el.on(name, on)\n\t  }\n\t\n\t  el.trigger = function(name) {\n\t    var args = [].slice.call(arguments, 1),\n\t        fns = callbacks[name] || []\n\t\n\t    for (var i = 0, fn; (fn = fns[i]); ++i) {\n\t      if (!fn.busy) {\n\t        fn.busy = 1\n\t        fn.apply(el, fn.typed ? [name].concat(args) : args)\n\t        if (fns[i] !== fn) { i-- }\n\t        fn.busy = 0\n\t      }\n\t    }\n\t\n\t    if (callbacks.all && name != 'all') {\n\t      el.trigger.apply(el, ['all', name].concat(args))\n\t    }\n\t\n\t    return el\n\t  }\n\t\n\t  return el\n\t\n\t}\n\triot.mixin = (function() {\n\t  var mixins = {}\n\t\n\t  return function(name, mixin) {\n\t    if (!mixin) return mixins[name]\n\t    mixins[name] = mixin\n\t  }\n\t\n\t})()\n\t\n\t;(function(riot, evt, win) {\n\t\n\t  // browsers only\n\t  if (!win) return\n\t\n\t  var loc = win.location,\n\t      fns = riot.observable(),\n\t      started = false,\n\t      current\n\t\n\t  function hash() {\n\t    return loc.href.split('#')[1] || ''\n\t  }\n\t\n\t  function parser(path) {\n\t    return path.split('/')\n\t  }\n\t\n\t  function emit(path) {\n\t    if (path.type) path = hash()\n\t\n\t    if (path != current) {\n\t      fns.trigger.apply(null, ['H'].concat(parser(path)))\n\t      current = path\n\t    }\n\t  }\n\t\n\t  var r = riot.route = function(arg) {\n\t    // string\n\t    if (arg[0]) {\n\t      loc.hash = arg\n\t      emit(arg)\n\t\n\t    // function\n\t    } else {\n\t      fns.on('H', arg)\n\t    }\n\t  }\n\t\n\t  r.exec = function(fn) {\n\t    fn.apply(null, parser(hash()))\n\t  }\n\t\n\t  r.parser = function(fn) {\n\t    parser = fn\n\t  }\n\t\n\t  r.stop = function () {\n\t    if (!started) return\n\t    win.removeEventListener ? win.removeEventListener(evt, emit, false) : win.detachEvent('on' + evt, emit)\n\t    fns.off('*')\n\t    started = false\n\t  }\n\t\n\t  r.start = function () {\n\t    if (started) return\n\t    win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n\t    started = true\n\t  }\n\t\n\t  // autostart the router\n\t  r.start()\n\t\n\t})(riot, 'hashchange', window)\n\t/*\n\t\n\t//// How it works?\n\t\n\t\n\tThree ways:\n\t\n\t1. Expressions: tmpl('{ value }', data).\n\t   Returns the result of evaluated expression as a raw object.\n\t\n\t2. Templates: tmpl('Hi { name } { surname }', data).\n\t   Returns a string with evaluated expressions.\n\t\n\t3. Filters: tmpl('{ show: !done, highlight: active }', data).\n\t   Returns a space separated list of trueish keys (mainly\n\t   used for setting html classes), e.g. \"show highlight\".\n\t\n\t\n\t// Template examples\n\t\n\ttmpl('{ title || \"Untitled\" }', data)\n\ttmpl('Results are { results ? \"ready\" : \"loading\" }', data)\n\ttmpl('Today is { new Date() }', data)\n\ttmpl('{ message.length > 140 && \"Message is too long\" }', data)\n\ttmpl('This item got { Math.round(rating) } stars', data)\n\ttmpl('<h1>{ title }</h1>{ body }', data)\n\t\n\t\n\t// Falsy expressions in templates\n\t\n\tIn templates (as opposed to single expressions) all falsy values\n\texcept zero (undefined/null/false) will default to empty string:\n\t\n\ttmpl('{ undefined } - { false } - { null } - { 0 }', {})\n\t// will return: \" - - - 0\"\n\t\n\t*/\n\t\n\t\n\tvar brackets = (function(orig) {\n\t\n\t  var cachedBrackets,\n\t      r,\n\t      b,\n\t      re = /[{}]/g\n\t\n\t  return function(x) {\n\t\n\t    // make sure we use the current setting\n\t    var s = riot.settings.brackets || orig\n\t\n\t    // recreate cached vars if needed\n\t    if (cachedBrackets !== s) {\n\t      cachedBrackets = s\n\t      b = s.split(' ')\n\t      r = b.map(function (e) { return e.replace(/(?=.)/g, '\\\\') })\n\t    }\n\t\n\t    // if regexp given, rewrite it with current brackets (only if differ from default)\n\t    return x instanceof RegExp ? (\n\t        s === orig ? x :\n\t        new RegExp(x.source.replace(re, function(b) { return r[~~(b === '}')] }), x.global ? 'g' : '')\n\t      ) :\n\t      // else, get specific bracket\n\t      b[x]\n\t  }\n\t})('{ }')\n\t\n\t\n\tvar tmpl = (function() {\n\t\n\t  var cache = {},\n\t      reVars = /(['\"\\/]).*?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_$]\\w*)/gi\n\t              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n\t              // find variable names:\n\t              // 1. skip quoted strings and regexps: \"a b\", 'a b', 'a \\'b\\'', /a b/\n\t              // 2. skip object properties: .name\n\t              // 3. skip object literals: name:\n\t              // 4. skip javascript keywords\n\t              // 5. match var name\n\t\n\t  // build a template (or get it from cache), render with data\n\t  return function(str, data) {\n\t    return str && (cache[str] = cache[str] || tmpl(str))(data)\n\t  }\n\t\n\t\n\t  // create a template instance\n\t\n\t  function tmpl(s, p) {\n\t\n\t    // default template string to {}\n\t    s = (s || (brackets(0) + brackets(1)))\n\t\n\t      // temporarily convert \\{ and \\} to a non-character\n\t      .replace(brackets(/\\\\{/g), '\\uFFF0')\n\t      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\t\n\t    // split string to expression and non-expresion parts\n\t    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\t\n\t    return new Function('d', 'return ' + (\n\t\n\t      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n\t      !p[0] && !p[2] && !p[3]\n\t\n\t        // if expression, evaluate it\n\t        ? expr(p[1])\n\t\n\t        // if template, evaluate all expressions in it\n\t        : '[' + p.map(function(s, i) {\n\t\n\t            // is it an expression or a string (every second part is an expression)\n\t          return i % 2\n\t\n\t              // evaluate the expressions\n\t              ? expr(s, true)\n\t\n\t              // process string parts of the template:\n\t              : '\"' + s\n\t\n\t                  // preserve new lines\n\t                  .replace(/\\n/g, '\\\\n')\n\t\n\t                  // escape quotes\n\t                  .replace(/\"/g, '\\\\\"')\n\t\n\t                + '\"'\n\t\n\t        }).join(',') + '].join(\"\")'\n\t      )\n\t\n\t      // bring escaped { and } back\n\t      .replace(/\\uFFF0/g, brackets(0))\n\t      .replace(/\\uFFF1/g, brackets(1))\n\t\n\t    + ';')\n\t\n\t  }\n\t\n\t\n\t  // parse { ... } expression\n\t\n\t  function expr(s, n) {\n\t    s = s\n\t\n\t      // convert new lines to spaces\n\t      .replace(/\\n/g, ' ')\n\t\n\t      // trim whitespace, brackets, strip comments\n\t      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\t\n\t    // is it an object literal? i.e. { key : value }\n\t    return /^\\s*[\\w- \"']+ *:/.test(s)\n\t\n\t      // if object literal, return trueish keys\n\t      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n\t      ? '[' +\n\t\n\t          // extract key:val pairs, ignoring any nested objects\n\t          extract(s,\n\t\n\t              // name part: name:, \"name\":, 'name':, name :\n\t              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\t\n\t              // expression part: everything upto a comma followed by a name (see above) or end of line\n\t              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n\t              ).map(function(pair) {\n\t\n\t                // get key, val parts\n\t                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\t\n\t                  // wrap all conditional parts to ignore errors\n\t                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\t\n\t                })\n\t\n\t              }).join('')\n\t\n\t        + '].join(\" \").trim()'\n\t\n\t      // if js expression, evaluate as javascript\n\t      : wrap(s, n)\n\t\n\t  }\n\t\n\t\n\t  // execute js w/o breaking on errors or undefined vars\n\t\n\t  function wrap(s, nonull) {\n\t    s = s.trim()\n\t    return !s ? '' : '(function(v){try{v='\n\t\n\t        // prefix vars (name => data.name)\n\t        + (s.replace(reVars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })\n\t\n\t          // break the expression if its empty (resulting in undefined value)\n\t          || 'x')\n\t      + '}catch(e){'\n\t      + '}finally{return '\n\t\n\t        // default to empty string for falsy values except zero\n\t        + (nonull === true ? '!v&&v!==0?\"\":v' : 'v')\n\t\n\t      + '}}).call(d)'\n\t  }\n\t\n\t\n\t  // split string by an array of substrings\n\t\n\t  function split(str, substrings) {\n\t    var parts = []\n\t    substrings.map(function(sub, i) {\n\t\n\t      // push matched expression and part before it\n\t      i = str.indexOf(sub)\n\t      parts.push(str.slice(0, i), sub)\n\t      str = str.slice(i + sub.length)\n\t    })\n\t\n\t    // push the remaining part\n\t    return parts.concat(str)\n\t  }\n\t\n\t\n\t  // match strings between opening and closing regexp, skipping any inner/nested matches\n\t\n\t  function extract(str, open, close) {\n\t\n\t    var start,\n\t        level = 0,\n\t        matches = [],\n\t        re = new RegExp('('+open.source+')|('+close.source+')', 'g')\n\t\n\t    str.replace(re, function(_, open, close, pos) {\n\t\n\t      // if outer inner bracket, mark position\n\t      if (!level && open) start = pos\n\t\n\t      // in(de)crease bracket level\n\t      level += open ? 1 : -1\n\t\n\t      // if outer closing bracket, grab the match\n\t      if (!level && close != null) matches.push(str.slice(start, pos+close.length))\n\t\n\t    })\n\t\n\t    return matches\n\t  }\n\t\n\t})()\n\t\n\t// { key, i in items} -> { key, i, items }\n\tfunction loopKeys(expr) {\n\t  var b0 = brackets(0),\n\t      els = expr.slice(b0.length).match(/^\\s*(\\S+?)\\s*(?:,\\s*(\\S+))?\\s+in\\s+(.+)$/)\n\t  return els ? { key: els[1], pos: els[2], val: b0 + els[3] } : { val: expr }\n\t}\n\t\n\tfunction mkitem(expr, key, val) {\n\t  var item = {}\n\t  item[expr.key] = key\n\t  if (expr.pos) item[expr.pos] = val\n\t  return item\n\t}\n\t\n\t\n\t/* Beware: heavy stuff */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  remAttr(dom, 'each')\n\t\n\t  var tagName = getTagName(dom),\n\t      template = dom.outerHTML,\n\t      hasImpl = !!tagImpl[tagName],\n\t      impl = tagImpl[tagName] || {\n\t        tmpl: template\n\t      },\n\t      root = dom.parentNode,\n\t      placeholder = document.createComment('riot placeholder'),\n\t      tags = [],\n\t      child = getTag(dom),\n\t      checksum\n\t\n\t  root.insertBefore(placeholder, dom)\n\t\n\t  expr = loopKeys(expr)\n\t\n\t  // clean template code\n\t  parent\n\t    .one('premount', function () {\n\t      if (root.stub) root = parent.root\n\t      // remove the original DOM node\n\t      dom.parentNode.removeChild(dom)\n\t    })\n\t    .on('update', function () {\n\t      var items = tmpl(expr.val, parent)\n\t\n\t      // object loop. any changes cause full redraw\n\t      if (!isArray(items)) {\n\t\n\t        checksum = items ? JSON.stringify(items) : ''\n\t\n\t        items = !items ? [] :\n\t          Object.keys(items).map(function (key) {\n\t            return mkitem(expr, key, items[key])\n\t          })\n\t      }\n\t\n\t      var frag = document.createDocumentFragment(),\n\t          i = tags.length,\n\t          j = items.length\n\t\n\t      // unmount leftover items\n\t      while (i > j) {\n\t        tags[--i].unmount()\n\t        tags.splice(i, 1)\n\t      }\n\t\n\t      for (i = 0; i < j; ++i) {\n\t        var _item = !checksum && !!expr.key ? mkitem(expr, items[i], i) : items[i]\n\t\n\t        if (!tags[i]) {\n\t          // mount new\n\t          (tags[i] = new Tag(impl, {\n\t              parent: parent,\n\t              isLoop: true,\n\t              hasImpl: hasImpl,\n\t              root: hasImpl ? dom.cloneNode() : root,\n\t              item: _item\n\t            }, dom.innerHTML)\n\t          ).mount()\n\t\n\t          frag.appendChild(tags[i].root)\n\t        } else\n\t          tags[i].update(_item)\n\t\n\t        tags[i]._item = _item\n\t\n\t      }\n\t\n\t      root.insertBefore(frag, placeholder)\n\t\n\t      if (child) parent.tags[tagName] = tags\n\t\n\t    }).one('updated', function() {\n\t      var keys = Object.keys(parent)// only set new values\n\t      walk(root, function(node) {\n\t        // only set element node and not isLoop\n\t        if (node.nodeType == 1 && !node.isLoop && !node._looped) {\n\t          node._visited = false // reset _visited for loop node\n\t          node._looped = true // avoid set multiple each\n\t          setNamed(node, parent, keys)\n\t        }\n\t      })\n\t    })\n\t\n\t}\n\t\n\t\n\tfunction parseNamedElements(root, parent, childTags) {\n\t\n\t  walk(root, function(dom) {\n\t    if (dom.nodeType == 1) {\n\t      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || dom.getAttribute('each')) ? 1 : 0\n\t\n\t      // custom child tag\n\t      var child = getTag(dom)\n\t\n\t      if (child && !dom.isLoop) {\n\t        var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),\n\t            tagName = getTagName(dom),\n\t            ptag = parent,\n\t            cachedTag\n\t\n\t        while (!getTag(ptag.root)) {\n\t          if (!ptag.parent) break\n\t          ptag = ptag.parent\n\t        }\n\t\n\t        // fix for the parent attribute in the looped elements\n\t        tag.parent = ptag\n\t\n\t        cachedTag = ptag.tags[tagName]\n\t\n\t        // if there are multiple children tags having the same name\n\t        if (cachedTag) {\n\t          // if the parent tags property is not yet an array\n\t          // create it adding the first cached tag\n\t          if (!isArray(cachedTag))\n\t            ptag.tags[tagName] = [cachedTag]\n\t          // add the new nested tag to the array\n\t          ptag.tags[tagName].push(tag)\n\t        } else {\n\t          ptag.tags[tagName] = tag\n\t        }\n\t\n\t        // empty the child node once we got its template\n\t        // to avoid that its children get compiled multiple times\n\t        dom.innerHTML = ''\n\t        childTags.push(tag)\n\t      }\n\t\n\t      if (!dom.isLoop)\n\t        setNamed(dom, parent, [])\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction parseExpressions(root, tag, expressions) {\n\t\n\t  function addExpr(dom, val, extra) {\n\t    if (val.indexOf(brackets(0)) >= 0) {\n\t      var expr = { dom: dom, expr: val }\n\t      expressions.push(extend(expr, extra))\n\t    }\n\t  }\n\t\n\t  walk(root, function(dom) {\n\t    var type = dom.nodeType\n\t\n\t    // text node\n\t    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n\t    if (type != 1) return\n\t\n\t    /* element */\n\t\n\t    // loop\n\t    var attr = dom.getAttribute('each')\n\t\n\t    if (attr) { _each(dom, tag, attr); return false }\n\t\n\t    // attribute expressions\n\t    each(dom.attributes, function(attr) {\n\t      var name = attr.name,\n\t        bool = name.split('__')[1]\n\t\n\t      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n\t      if (bool) { remAttr(dom, name); return false }\n\t\n\t    })\n\t\n\t    // skip custom tags\n\t    if (getTag(dom)) return false\n\t\n\t  })\n\t\n\t}\n\tfunction Tag(impl, conf, innerHTML) {\n\t\n\t  var self = riot.observable(this),\n\t      opts = inherit(conf.opts) || {},\n\t      dom = mkdom(impl.tmpl),\n\t      parent = conf.parent,\n\t      isLoop = conf.isLoop,\n\t      hasImpl = conf.hasImpl,\n\t      item = cleanUpData(conf.item),\n\t      expressions = [],\n\t      childTags = [],\n\t      root = conf.root,\n\t      fn = impl.fn,\n\t      tagName = root.tagName.toLowerCase(),\n\t      attr = {},\n\t      propsInSyncWithParent = [],\n\t      loopDom,\n\t      TAG_ATTRIBUTES = /([\\w\\-]+)\\s?=\\s?['\"]([^'\"]+)[\"']/gim\n\t\n\t\n\t  if (fn && root._tag) {\n\t    root._tag.unmount(true)\n\t  }\n\t\n\t  // not yet mounted\n\t  this.isMounted = false\n\t  root.isLoop = isLoop\n\t\n\t  if (impl.attrs) {\n\t    var attrs = impl.attrs.match(TAG_ATTRIBUTES)\n\t\n\t    each(attrs, function(a) {\n\t      var kv = a.split(/\\s?=\\s?/)\n\t      root.setAttribute(kv[0], kv[1].replace(/['\"]/g, ''))\n\t    })\n\t\n\t  }\n\t\n\t  // keep a reference to the tag just created\n\t  // so we will be able to mount this tag multiple times\n\t  root._tag = this\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  this._id = fastAbs(~~(new Date().getTime() * Math.random()))\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\t\n\t  // grab attributes\n\t  each(root.attributes, function(el) {\n\t    var val = el.value\n\t    // remember attributes with expressions only\n\t    if (brackets(/\\{.*\\}/).test(val)) attr[el.name] = val\n\t  })\n\t\n\t  if (dom.innerHTML && !/select|select|optgroup|tbody|tr/.test(tagName))\n\t    // replace all the yield tags with the tag inner html\n\t    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\t\n\t  // options\n\t  function updateOpts() {\n\t    var ctx = hasImpl && isLoop ? self : parent || self\n\t    // update opts from current DOM attributes\n\t    each(root.attributes, function(el) {\n\t      opts[el.name] = tmpl(el.value, ctx)\n\t    })\n\t    // recover those with expressions\n\t    each(Object.keys(attr), function(name) {\n\t      opts[name] = tmpl(attr[name], ctx)\n\t    })\n\t  }\n\t\n\t  function normalizeData(data) {\n\t    for (var key in item) {\n\t      if (typeof self[key] !== T_UNDEF)\n\t        self[key] = data[key]\n\t    }\n\t  }\n\t\n\t  function inheritFromParent () {\n\t    if (!self.parent || !isLoop) return\n\t    each(Object.keys(self.parent), function(k) {\n\t      // some properties must be always in sync with the parent tag\n\t      var mustSync = ~propsInSyncWithParent.indexOf(k)\n\t      if (typeof self[k] === T_UNDEF || mustSync) {\n\t        // track the property to keep in sync\n\t        // so we can keep it updated\n\t        if (!mustSync) propsInSyncWithParent.push(k)\n\t        self[k] = self.parent[k]\n\t      }\n\t    })\n\t  }\n\t\n\t  this.update = function(data) {\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data)\n\t    // inherit properties from the parent\n\t    inheritFromParent()\n\t    // normalize the tag properties in case an item object was initially passed\n\t    if (typeof item === T_OBJECT || isArray(item)) {\n\t      normalizeData(data)\n\t      item = data\n\t    }\n\t    extend(self, data)\n\t    updateOpts()\n\t    self.trigger('update', data)\n\t    update(expressions, self)\n\t    self.trigger('updated')\n\t  }\n\t\n\t  this.mixin = function() {\n\t    each(arguments, function(mix) {\n\t      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\t      each(Object.keys(mix), function(key) {\n\t        // bind methods to self\n\t        if (key != 'init')\n\t          self[key] = isFunction(mix[key]) ? mix[key].bind(self) : mix[key]\n\t      })\n\t      // init method will be called automatically\n\t      if (mix.init) mix.init.bind(self)()\n\t    })\n\t  }\n\t\n\t  this.mount = function() {\n\t\n\t    updateOpts()\n\t\n\t    // initialiation\n\t    fn && fn.call(self, opts)\n\t\n\t    toggle(true)\n\t\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions(dom, self, expressions)\n\t    if (!self.parent || hasImpl) parseExpressions(self.root, self, expressions) // top level before update, empty root\n\t\n\t    if (!self.parent || isLoop) self.update(item)\n\t\n\t    // internal use only, fixes #403\n\t    self.trigger('premount')\n\t\n\t    if (isLoop && !hasImpl) {\n\t      // update the root attribute for the looped elements\n\t      self.root = root = loopDom = dom.firstChild\n\t\n\t    } else {\n\t      while (dom.firstChild) root.appendChild(dom.firstChild)\n\t      if (root.stub) self.root = root = parent.root\n\t    }\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!self.parent || self.parent.isMounted) {\n\t      self.isMounted = true\n\t      self.trigger('mount')\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else self.parent.one('mount', function() {\n\t      // avoid to trigger the `mount` event for the tags\n\t      // not visible included in an if statement\n\t      if (!isInStub(self.root)) {\n\t        self.parent.isMounted = self.isMounted = true\n\t        self.trigger('mount')\n\t      }\n\t    })\n\t  }\n\t\n\t\n\t  this.unmount = function(keepRootTag) {\n\t    var el = loopDom || root,\n\t        p = el.parentNode\n\t\n\t    if (p) {\n\t\n\t      if (parent)\n\t        // remove this tag from the parent tags object\n\t        // if there are multiple nested tags with same name..\n\t        // remove this element form the array\n\t        if (isArray(parent.tags[tagName]))\n\t          each(parent.tags[tagName], function(tag, i) {\n\t            if (tag._id == self._id)\n\t              parent.tags[tagName].splice(i, 1)\n\t          })\n\t        else\n\t          // otherwise just delete the tag instance\n\t          parent.tags[tagName] = undefined\n\t      else\n\t        while (el.firstChild) el.removeChild(el.firstChild)\n\t\n\t      if (!keepRootTag)\n\t        p.removeChild(el)\n\t\n\t    }\n\t\n\t\n\t    self.trigger('unmount')\n\t    toggle()\n\t    self.off('*')\n\t    // somehow ie8 does not like `delete root._tag`\n\t    root._tag = null\n\t\n\t  }\n\t\n\t  function toggle(isMount) {\n\t\n\t    // mount/unmount children\n\t    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\t\n\t    // listen/unlisten parent (events flow one way from parent to children)\n\t    if (parent) {\n\t      var evt = isMount ? 'on' : 'off'\n\t\n\t      // the loop tags will be always in sync with the parent automatically\n\t      if (isLoop)\n\t        parent[evt]('unmount', self.unmount)\n\t      else\n\t        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n\t    }\n\t  }\n\t\n\t  // named elements available for fn\n\t  parseNamedElements(dom, this, childTags)\n\t\n\t\n\t}\n\t\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t\n\t  dom[name] = function(e) {\n\t\n\t    var item = tag._item,\n\t        ptag = tag.parent\n\t\n\t    if (!item)\n\t      while (ptag) {\n\t        item = ptag._item\n\t        ptag = item ? false : ptag.parent\n\t      }\n\t\n\t    // cross browser event fix\n\t    e = e || window.event\n\t\n\t    // ignore error on some browsers\n\t    try {\n\t      e.currentTarget = dom\n\t      if (!e.target) e.target = e.srcElement\n\t      if (!e.which) e.which = e.charCode || e.keyCode\n\t    } catch (ignored) { '' }\n\t\n\t    e.item = item\n\t\n\t    // prevent default behaviour (by default)\n\t    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n\t      e.preventDefault && e.preventDefault()\n\t      e.returnValue = false\n\t    }\n\t\n\t    if (!e.preventUpdate) {\n\t      var el = item ? tag.parent : tag\n\t      el.update()\n\t    }\n\t\n\t  }\n\t\n\t}\n\t\n\t// used by if- attribute\n\tfunction insertTo(root, node, before) {\n\t  if (root) {\n\t    root.insertBefore(before, node)\n\t    root.removeChild(node)\n\t  }\n\t}\n\t\n\tfunction update(expressions, tag) {\n\t\n\t  each(expressions, function(expr, i) {\n\t\n\t    var dom = expr.dom,\n\t        attrName = expr.attr,\n\t        value = tmpl(expr.expr, tag),\n\t        parent = expr.dom.parentNode\n\t\n\t    if (value == null) value = ''\n\t\n\t    // leave out riot- prefixes from strings inside textarea\n\t    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')\n\t\n\t    // no change\n\t    if (expr.value === value) return\n\t    expr.value = value\n\t\n\t    // text node\n\t    if (!attrName) return dom.nodeValue = value.toString()\n\t\n\t    // remove original attribute\n\t    remAttr(dom, attrName)\n\t\n\t    // event handler\n\t    if (isFunction(value)) {\n\t      setEventHandler(attrName, value, dom, tag)\n\t\n\t    // if- conditional\n\t    } else if (attrName == 'if') {\n\t      var stub = expr.stub\n\t\n\t      // add to DOM\n\t      if (value) {\n\t        if (stub) {\n\t          insertTo(stub.parentNode, stub, dom)\n\t          dom.inStub = false\n\t          // avoid to trigger the mount event if the tags is not visible yet\n\t          // maybe we can optimize this avoiding to mount the tag at all\n\t          if (!isInStub(dom)) {\n\t            walk(dom, function(el) {\n\t              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n\t            })\n\t          }\n\t        }\n\t      // remove from DOM\n\t      } else {\n\t        stub = expr.stub = stub || document.createTextNode('')\n\t        insertTo(dom.parentNode, dom, stub)\n\t        dom.inStub = true\n\t      }\n\t    // show / hide\n\t    } else if (/^(show|hide)$/.test(attrName)) {\n\t      if (attrName == 'hide') value = !value\n\t      dom.style.display = value ? '' : 'none'\n\t\n\t    // field value\n\t    } else if (attrName == 'value') {\n\t      dom.value = value\n\t\n\t    // <img src=\"{ expr }\">\n\t    } else if (attrName.slice(0, 5) == 'riot-' && attrName != 'riot-tag') {\n\t      attrName = attrName.slice(5)\n\t      value ? dom.setAttribute(attrName, value) : remAttr(dom, attrName)\n\t\n\t    } else {\n\t      if (expr.bool) {\n\t        dom[attrName] = value\n\t        if (!value) return\n\t        value = attrName\n\t      }\n\t\n\t      if (typeof value !== T_OBJECT) dom.setAttribute(attrName, value)\n\t\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction each(els, fn) {\n\t  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n\t    el = els[i]\n\t    // return false -> remove current item during loop\n\t    if (el != null && fn(el, i) === false) i--\n\t  }\n\t  return els\n\t}\n\t\n\tfunction isFunction(v) {\n\t  return typeof v === 'function' || false   // avoid IE problems\n\t}\n\t\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name)\n\t}\n\t\n\tfunction fastAbs(nr) {\n\t  return (nr ^ (nr >> 31)) - (nr >> 31)\n\t}\n\t\n\tfunction getTag(dom) {\n\t  var tagName = dom.tagName.toLowerCase()\n\t  return tagImpl[dom.getAttribute(RIOT_TAG) || tagName]\n\t}\n\t\n\tfunction getTagName(dom) {\n\t  var child = getTag(dom),\n\t    namedTag = dom.getAttribute('name'),\n\t    tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child ? child.name : dom.tagName.toLowerCase()\n\t\n\t  return tagName\n\t}\n\t\n\tfunction extend(src) {\n\t  var obj, args = arguments\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if ((obj = args[i])) {\n\t      for (var key in obj) {      // eslint-disable-line guard-for-in\n\t        src[key] = obj[key]\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\t// with this function we avoid that the current Tag methods get overridden\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag)) return data\n\t\n\t  var o = {},\n\t      blackList = ['update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isloop', 'tags', 'parent', 'opts']\n\t  for (var key in data) {\n\t    if (!~blackList.indexOf(key))\n\t      o[key] = data[key]\n\t  }\n\t  return o\n\t}\n\t\n\tfunction mkdom(template) {\n\t  var checkie = ieVersion && ieVersion < 10,\n\t      matches = /^\\s*<([\\w-]+)/.exec(template),\n\t      tagName = matches ? matches[1].toLowerCase() : '',\n\t      rootTag = (tagName === 'th' || tagName === 'td') ? 'tr' :\n\t                (tagName === 'tr' ? 'tbody' : 'div'),\n\t      el = mkEl(rootTag)\n\t\n\t  el.stub = true\n\t\n\t  if (checkie) {\n\t    if (tagName === 'optgroup')\n\t      optgroupInnerHTML(el, template)\n\t    else if (tagName === 'option')\n\t      optionInnerHTML(el, template)\n\t    else if (rootTag !== 'div')\n\t      tbodyInnerHTML(el, template, tagName)\n\t    else\n\t      checkie = 0\n\t  }\n\t  if (!checkie) el.innerHTML = template\n\t\n\t  return el\n\t}\n\t\n\tfunction walk(dom, fn) {\n\t  if (dom) {\n\t    if (fn(dom) === false) walk(dom.nextSibling, fn)\n\t    else {\n\t      dom = dom.firstChild\n\t\n\t      while (dom) {\n\t        walk(dom, fn)\n\t        dom = dom.nextSibling\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub) return true\n\t    dom = dom.parentNode\n\t  }\n\t  return false\n\t}\n\t\n\tfunction mkEl(name) {\n\t  return document.createElement(name)\n\t}\n\t\n\tfunction replaceYield (tmpl, innerHTML) {\n\t  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gim, innerHTML || '')\n\t}\n\t\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\tfunction inherit(parent) {\n\t  function Child() {}\n\t  Child.prototype = parent\n\t  return new Child()\n\t}\n\t\n\tfunction setNamed(dom, parent, keys) {\n\t  each(dom.attributes, function(attr) {\n\t    if (dom._visited) return\n\t    if (attr.name === 'id' || attr.name === 'name') {\n\t      dom._visited = true\n\t      var p, v = attr.value\n\t      if (~keys.indexOf(v)) return\n\t\n\t      p = parent[v]\n\t      if (!p)\n\t        parent[v] = dom\n\t      else\n\t        isArray(p) ? p.push(dom) : (parent[v] = [p, dom])\n\t    }\n\t  })\n\t}\n\t/**\n\t *\n\t * Hacks needed for the old internet explorer versions [lower than IE10]\n\t *\n\t */\n\t/* istanbul ignore next */\n\tfunction tbodyInnerHTML(el, html, tagName) {\n\t  var div = mkEl('div'),\n\t      loops = /td|th/.test(tagName) ? 3 : 2,\n\t      child\n\t\n\t  div.innerHTML = '<table>' + html + '</table>'\n\t  child = div.firstChild\n\t\n\t  while (loops--) child = child.firstChild\n\t\n\t  el.appendChild(child)\n\t\n\t}\n\t/* istanbul ignore next */\n\tfunction optionInnerHTML(el, html) {\n\t  var opt = mkEl('option'),\n\t      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n\t      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n\t      eachRegx = /each=[\\\"'](.+?)[\\\"']/,\n\t      ifRegx = /if=[\\\"'](.+?)[\\\"']/,\n\t      innerRegx = />([^<]*)</,\n\t      valuesMatch = html.match(valRegx),\n\t      selectedMatch = html.match(selRegx),\n\t      innerValue = html.match(innerRegx),\n\t      eachMatch = html.match(eachRegx),\n\t      ifMatch = html.match(ifRegx)\n\t\n\t  if (innerValue) opt.innerHTML = innerValue[1]\n\t  else opt.innerHTML = html\n\t\n\t  if (valuesMatch) opt.value = valuesMatch[1]\n\t  if (selectedMatch) opt.setAttribute('riot-selected', selectedMatch[1])\n\t  if (eachMatch) opt.setAttribute('each', eachMatch[1])\n\t  if (ifMatch) opt.setAttribute('if', ifMatch[1])\n\t\n\t  el.appendChild(opt)\n\t}\n\t/* istanbul ignore next */\n\tfunction optgroupInnerHTML(el, html) {\n\t  var opt = mkEl('optgroup'),\n\t      labelRegx = /label=[\\\"'](.+?)[\\\"']/,\n\t      elementRegx = /^<([^>]*)>/,\n\t      tagRegx = /^<([^ \\>]*)/,\n\t      labelMatch = html.match(labelRegx),\n\t      elementMatch = html.match(elementRegx),\n\t      tagMatch = html.match(tagRegx),\n\t      innerContent = html\n\t\n\t  if (elementMatch) {\n\t    var options = html.slice(elementMatch[1].length+2, -tagMatch[1].length-3).trim()\n\t    innerContent = options\n\t  }\n\t\n\t  if (labelMatch) opt.setAttribute('riot-label', labelMatch[1])\n\t\n\t  if (innerContent) {\n\t    var innerOpt = mkEl('div')\n\t\n\t    optionInnerHTML(innerOpt, innerContent)\n\t\n\t    opt.appendChild(innerOpt.firstChild)\n\t  }\n\t\n\t  el.appendChild(opt)\n\t}\n\t\n\t/*\n\t Virtual dom is an array of custom tags on the document.\n\t Updates and unmounts propagate downwards from parent to children.\n\t*/\n\t\n\tvar virtualDom = [],\n\t    tagImpl = {},\n\t    styleNode\n\t\n\tvar RIOT_TAG = 'riot-tag'\n\t\n\tfunction injectStyle(css) {\n\t\n\t  styleNode = styleNode || mkEl('style')\n\t\n\t  if (!document.head) return\n\t\n\t  if (styleNode.styleSheet)\n\t    styleNode.styleSheet.cssText += css\n\t  else\n\t    styleNode.innerHTML += css\n\t\n\t  if (!styleNode._rendered)\n\t    if (styleNode.styleSheet) {\n\t      document.body.appendChild(styleNode)\n\t    } else {\n\t      var rs = $('style[type=riot]')\n\t      if (rs) {\n\t        rs.parentNode.insertBefore(styleNode, rs)\n\t        rs.parentNode.removeChild(rs)\n\t      } else document.head.appendChild(styleNode)\n\t\n\t    }\n\t\n\t  styleNode._rendered = true\n\t\n\t}\n\t\n\tfunction mountTo(root, tagName, opts) {\n\t  var tag = tagImpl[tagName],\n\t      // cache the inner HTML to fix #855\n\t      innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\t\n\t  // clear the inner html\n\t  root.innerHTML = ''\n\t\n\t  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount()\n\t    virtualDom.push(tag)\n\t    return tag.on('unmount', function() {\n\t      virtualDom.splice(virtualDom.indexOf(tag), 1)\n\t    })\n\t  }\n\t\n\t}\n\t\n\triot.tag = function(name, html, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css\n\t      css = ''\n\t    } else attrs = ''\n\t  }\n\t  if (css) {\n\t    if (isFunction(css)) fn = css\n\t    else injectStyle(css)\n\t  }\n\t  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\triot.mount = function(selector, tagName, opts) {\n\t\n\t  var els,\n\t      allTags,\n\t      tags = []\n\t\n\t  // helper functions\n\t\n\t  function addRiotTags(arr) {\n\t    var list = ''\n\t    each(arr, function (e) {\n\t      list += ', *[riot-tag=\"'+ e.trim() + '\"]'\n\t    })\n\t    return list\n\t  }\n\t\n\t  function selectAllTags() {\n\t    var keys = Object.keys(tagImpl)\n\t    return keys + addRiotTags(keys)\n\t  }\n\t\n\t  function pushTags(root) {\n\t    if (root.tagName) {\n\t      if (tagName && !root.getAttribute(RIOT_TAG))\n\t        root.setAttribute(RIOT_TAG, tagName)\n\t\n\t      var tag = mountTo(root,\n\t        tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\t\n\t      if (tag) tags.push(tag)\n\t    }\n\t    else if (root.length) {\n\t      each(root, pushTags)   // assume nodeList\n\t    }\n\t  }\n\t\n\t  // ----- mount code -----\n\t\n\t  if (typeof tagName === T_OBJECT) {\n\t    opts = tagName\n\t    tagName = 0\n\t  }\n\t\n\t  // crawl the DOM to find the tag\n\t  if (typeof selector === T_STRING) {\n\t    if (selector === '*')\n\t      // select all the tags registered\n\t      // and also the tags found with the riot-tag attribute set\n\t      selector = allTags = selectAllTags()\n\t    else\n\t      // or just the ones named like the selector\n\t      selector += addRiotTags(selector.split(','))\n\t\n\t    els = $$(selector)\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    els = selector\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectAllTags()\n\t    // if the root els it's just a single tag\n\t    if (els.tagName)\n\t      els = $$(tagName, els)\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = []\n\t      each(els, function (_el) {\n\t        nodeList.push($$(tagName, _el))\n\t      })\n\t      els = nodeList\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0\n\t  }\n\t\n\t  if (els.tagName)\n\t    pushTags(els)\n\t  else\n\t    each(els, pushTags)\n\t\n\t  return tags\n\t}\n\t\n\t// update everything\n\triot.update = function() {\n\t  return each(virtualDom, function(tag) {\n\t    tag.update()\n\t  })\n\t}\n\t\n\t// @deprecated\n\triot.mountTo = riot.mount\n\t\n\t\n\t  // share methods for other riot parts, e.g. compiler\n\t  riot.util = { brackets: brackets, tmpl: tmpl }\n\t\n\t  // support CommonJS, AMD & browser\n\t  /* istanbul ignore next */\n\t  if (typeof exports === T_OBJECT)\n\t    module.exports = riot\n\t  else if (true)\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return window.riot = riot }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  else\n\t    window.riot = riot\n\t\n\t})(typeof window != 'undefined' ? window : undefined);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _RiotControlApi = ['on', 'one', 'off', 'trigger'];\n\tvar RiotControl = {\n\t  _stores: [],\n\t  addStore: function addStore(store) {\n\t    this._stores.push(store);\n\t  }\n\t};\n\t_RiotControlApi.forEach(function (api) {\n\t  RiotControl[api] = function () {\n\t    var args = [].slice.call(arguments);\n\t    this._stores.forEach(function (el) {\n\t      el[api].apply(null, args);\n\t    });\n\t  };\n\t});\n\t\n\tmodule.exports = RiotControl;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0;\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction createStyleElement() {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tvar head = getHeadElement();\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\thead.appendChild(styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement() {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tvar head = getHeadElement();\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\thead.appendChild(linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement();\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement();\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\texports['default'] = function (opts) {\n\t  this.title = 'This is the best title';\n\t};\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar control = __webpack_require__(2);\n\tvar todoStore = __webpack_require__(11);\n\t\n\tcontrol.addStore(todoStore);\n\triot.tag('feat-x', __webpack_require__(19), __webpack_require__(23), __webpack_require__(5));\n\triot.mount('feat-x');\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag('messenger', __webpack_require__(20), __webpack_require__(24), __webpack_require__(8));\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar control = __webpack_require__(2);\n\t\n\texports['default'] = function (opts) {\n\t  var _this = this;\n\t\n\t  this.count = 0;\n\t  control.on('change', function (items) {\n\t    _this.count = items.length;\n\t    _this.update();\n\t  });\n\t  control.on('todo_add', function (item) {\n\t    _this.count += 1;\n\t    _this.thing = item.title;\n\t    _this.update();\n\t  });\n\t  control.on('todo_remove', function () {\n\t    _this.count -= 1;\n\t    _this.update();\n\t  });\n\t\n\t  this.send = function (e) {\n\t    var msg = _this.message.value;\n\t    control.trigger('msg_sent', {\n\t      msg: _this.message.value\n\t    });\n\t    _this.message.value = '';\n\t  };\n\t};\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag('todo', __webpack_require__(21), __webpack_require__(25), __webpack_require__(10));\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar control = __webpack_require__(2);\n\t\n\texports['default'] = function (opts) {\n\t  var _this = this;\n\t\n\t  this.on('mount', function () {\n\t    control.trigger('todo_init');\n\t  });\n\t  control.on('change', function (items) {\n\t    _this.items = items;_this.update();\n\t  });\n\t\n\t  this.disabled = true;\n\t  this.items = [];\n\t\n\t  this.edit = function (e) {\n\t    _this.text = e.target.value;\n\t  };\n\t  this.add = function (e) {\n\t    if (_this.text) {\n\t      control.trigger('todo_add', { title: _this.text });\n\t      _this.text = _this.input.value = '';\n\t    }\n\t  };\n\t  this.toggle = function (e) {\n\t    var item = e.item;\n\t    item.done = !item.done;\n\t    return true;\n\t  };\n\t  this.remove = function (e) {\n\t    control.trigger('todo_remove');\n\t  };\n\t\n\t  control.on('msg_sent', function (msg) {\n\t    _this.msg = msg.msg;\n\t    _this.update();\n\t  });\n\t};\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {// TodoStore definition.\n\t// Flux stores house application logic and state that relate to a specific domain.\n\t// In this case, a list of todo items.\n\t\n\t'use strict';\n\t\n\tfunction TodoStore() {\n\t  var _this = this;\n\t\n\t  var store = riot.observable(this); // event emitter\n\t  this.todos = [{ title: 'Task 1', done: false }, { title: 'Task 2', done: false }];\n\t\n\t  this.stuff = [{ title: 'tt', done: false }, { title: 'tt', done: false }];\n\t\n\t  this.listen = function (e, fn, d, bn) {\n\t    var self = _this;\n\t    var config = { model: d, triggerName: bn ? bn : 'change' };\n\t    var broadcast = function broadcast() {\n\t      self.trigger(config.triggerName, config.model);\n\t    };\n\t    if (typeof fn === 'function') {\n\t      self.on(e, fn);\n\t      broadcast();\n\t    } else {\n\t      self.on(e, function () {\n\t        broadcast();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.listen('todo_init', 'broadcast', this.stuff);\n\t\n\t  this.listen('todo_add', function (newTodo) {\n\t    _this.stuff.push(newTodo);\n\t  });\n\t\n\t  this.listen('todo_remove', function () {\n\t    _this.stuff.pop();\n\t  });\n\t\n\t  return store;\n\t  // The store emits change events to any listening views, so that they may react and redraw themselves.\n\t}\n\t\n\tmodule.exports = new TodoStore();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag('widget', __webpack_require__(22), __webpack_require__(26), __webpack_require__(13));\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar control = __webpack_require__(2);\n\t\n\texports['default'] = function (opts) {\n\t  var _this = this;\n\t\n\t  control.on('msg_sent', function (msg) {\n\t    _this.msg = msg.msg;\n\t    _this.update();\n\t  });\n\t};\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(12);\n\t__webpack_require__(9);\n\t__webpack_require__(7);\n\t__webpack_require__(6);\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(3)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"todo-app{display:block;border:1px solid #ccc;padding:20px}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(3)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"messenger button{background-color:#fff;border:none;border:1px solid #ccc;padding:10px 20px}messenger input{padding:10px}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(3)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"todo button{background-color:#1fadc5;border:1px solid rgba(0,0,0,.2);font-size:100%;color:#fff;padding:.6em 1.2em;border-radius:3em;cursor:pointer;margin:0 .3em;outline:0}todo button[disabled]{background-color:#ddd;color:#aaa}todo input{font-size:100%;padding:.6em;border:1px solid #ccc;border-radius:3px}todo .completed{text-decoration:line-through;color:#ccc}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(3)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<h2>\\n<messenger></messenger>\\n  <todo></todo>\\n\\n  <widget></widget>\\n</h2>\"\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<p>this is the observer: count: { count }, added: { thing }</p>\\n\\n<form onsubmit=\\\"{ send }\\\">\\n  <input name=\\\"message\\\" onkeyup=\\\"{ edit }\\\">\\n  <button> send msg </button>\\n</form>\"\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<p>message:  { msg } </p>\\n<ul>\\n  <li each=\\\"{ items }\\\">\\n    <label class=\\\"{ completed: done }\\\">\\n      <input type=\\\"checkbox\\\" __checked=\\\"{ done }\\\" onclick=\\\"{ parent.toggle }\\\"> { title }\\n    </label>\\n  </li>\\n</ul>\\n<form onsubmit=\\\"{ add }\\\">\\n  <input name=\\\"input\\\" oninput=\\\"{ edit }\\\">\\n  <button __disabled=\\\"{ !text }\\\">Add #{ items.length + 1 }</button>\\n</form>\\n<button __disabled=\\\"{ !items.length }\\\" onclick=\\\"{ remove }\\\">Remove</button>\\n\"\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"  <p><strong>this is the widget and listening for messages { msg }</strong></p>\\n\"\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(15);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./feat-x.style.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./feat-x.style.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(16);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./messenger.style.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./messenger.style.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(17);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./todo.style.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./todo.style.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(18);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./widget.style.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./widget.style.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** main.entry.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/static/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6040df2aeb5d9c708643\n **/","'use strict';\n/*\n  To compile manually:\n    1. webpack config:\n    plugins: [\n       new webpack.ProvidePlugin({\n         riot: 'riot/riot+compiler.js'\n       })\n     ]\n    2. in your index.js set `window.riot = riot`\n    3. riot.compile(require('./app/app.tpl'));\n    4. riot.compile(require('./app/app.tag'));\n*/\n\nrequire('feature-x');\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","/* Riot v2.2.2, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window, undefined) {\n  'use strict'\n  var riot = { version: 'v2.2.2', settings: {} }\n\n  // This globals 'const' helps code size reduction\n\n  // for typeof == '' comparisons\n  var T_STRING = 'string',\n      T_OBJECT = 'object',\n      T_UNDEF  = 'undefined'\n\n  // for IE8 and rest of the world\n  /* istanbul ignore next */\n  var isArray = Array.isArray || (function () {\n    var _ts = Object.prototype.toString\n    return function (v) { return _ts.call(v) === '[object Array]' }\n  })()\n\n  // Version# for IE 8-11, 0 for others\n  var ieVersion = (function (win) {\n    return (window && window.document || {}).documentMode | 0\n  })()\n\nriot.observable = function(el) {\n\n  el = el || {}\n\n  var callbacks = {},\n      _id = 0\n\n  el.on = function(events, fn) {\n    if (isFunction(fn)) {\n      if (typeof fn.id === T_UNDEF) fn._id = _id++\n\n      events.replace(/\\S+/g, function(name, pos) {\n        (callbacks[name] = callbacks[name] || []).push(fn)\n        fn.typed = pos > 0\n      })\n    }\n    return el\n  }\n\n  el.off = function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      events.replace(/\\S+/g, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n            if (cb._id == fn._id) arr.splice(i--, 1)\n          }\n        } else {\n          callbacks[name] = []\n        }\n      })\n    }\n    return el\n  }\n\n  // only single event supported\n  el.one = function(name, fn) {\n    function on() {\n      el.off(name, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(name, on)\n  }\n\n  el.trigger = function(name) {\n    var args = [].slice.call(arguments, 1),\n        fns = callbacks[name] || []\n\n    for (var i = 0, fn; (fn = fns[i]); ++i) {\n      if (!fn.busy) {\n        fn.busy = 1\n        fn.apply(el, fn.typed ? [name].concat(args) : args)\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n    }\n\n    if (callbacks.all && name != 'all') {\n      el.trigger.apply(el, ['all', name].concat(args))\n    }\n\n    return el\n  }\n\n  return el\n\n}\nriot.mixin = (function() {\n  var mixins = {}\n\n  return function(name, mixin) {\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n;(function(riot, evt, win) {\n\n  // browsers only\n  if (!win) return\n\n  var loc = win.location,\n      fns = riot.observable(),\n      started = false,\n      current\n\n  function hash() {\n    return loc.href.split('#')[1] || ''\n  }\n\n  function parser(path) {\n    return path.split('/')\n  }\n\n  function emit(path) {\n    if (path.type) path = hash()\n\n    if (path != current) {\n      fns.trigger.apply(null, ['H'].concat(parser(path)))\n      current = path\n    }\n  }\n\n  var r = riot.route = function(arg) {\n    // string\n    if (arg[0]) {\n      loc.hash = arg\n      emit(arg)\n\n    // function\n    } else {\n      fns.on('H', arg)\n    }\n  }\n\n  r.exec = function(fn) {\n    fn.apply(null, parser(hash()))\n  }\n\n  r.parser = function(fn) {\n    parser = fn\n  }\n\n  r.stop = function () {\n    if (!started) return\n    win.removeEventListener ? win.removeEventListener(evt, emit, false) : win.detachEvent('on' + evt, emit)\n    fns.off('*')\n    started = false\n  }\n\n  r.start = function () {\n    if (started) return\n    win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n    started = true\n  }\n\n  // autostart the router\n  r.start()\n\n})(riot, 'hashchange', window)\n/*\n\n//// How it works?\n\n\nThree ways:\n\n1. Expressions: tmpl('{ value }', data).\n   Returns the result of evaluated expression as a raw object.\n\n2. Templates: tmpl('Hi { name } { surname }', data).\n   Returns a string with evaluated expressions.\n\n3. Filters: tmpl('{ show: !done, highlight: active }', data).\n   Returns a space separated list of trueish keys (mainly\n   used for setting html classes), e.g. \"show highlight\".\n\n\n// Template examples\n\ntmpl('{ title || \"Untitled\" }', data)\ntmpl('Results are { results ? \"ready\" : \"loading\" }', data)\ntmpl('Today is { new Date() }', data)\ntmpl('{ message.length > 140 && \"Message is too long\" }', data)\ntmpl('This item got { Math.round(rating) } stars', data)\ntmpl('<h1>{ title }</h1>{ body }', data)\n\n\n// Falsy expressions in templates\n\nIn templates (as opposed to single expressions) all falsy values\nexcept zero (undefined/null/false) will default to empty string:\n\ntmpl('{ undefined } - { false } - { null } - { 0 }', {})\n// will return: \" - - - 0\"\n\n*/\n\n\nvar brackets = (function(orig) {\n\n  var cachedBrackets,\n      r,\n      b,\n      re = /[{}]/g\n\n  return function(x) {\n\n    // make sure we use the current setting\n    var s = riot.settings.brackets || orig\n\n    // recreate cached vars if needed\n    if (cachedBrackets !== s) {\n      cachedBrackets = s\n      b = s.split(' ')\n      r = b.map(function (e) { return e.replace(/(?=.)/g, '\\\\') })\n    }\n\n    // if regexp given, rewrite it with current brackets (only if differ from default)\n    return x instanceof RegExp ? (\n        s === orig ? x :\n        new RegExp(x.source.replace(re, function(b) { return r[~~(b === '}')] }), x.global ? 'g' : '')\n      ) :\n      // else, get specific bracket\n      b[x]\n  }\n})('{ }')\n\n\nvar tmpl = (function() {\n\n  var cache = {},\n      reVars = /(['\"\\/]).*?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_$]\\w*)/gi\n              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n              // find variable names:\n              // 1. skip quoted strings and regexps: \"a b\", 'a b', 'a \\'b\\'', /a b/\n              // 2. skip object properties: .name\n              // 3. skip object literals: name:\n              // 4. skip javascript keywords\n              // 5. match var name\n\n  // build a template (or get it from cache), render with data\n  return function(str, data) {\n    return str && (cache[str] = cache[str] || tmpl(str))(data)\n  }\n\n\n  // create a template instance\n\n  function tmpl(s, p) {\n\n    // default template string to {}\n    s = (s || (brackets(0) + brackets(1)))\n\n      // temporarily convert \\{ and \\} to a non-character\n      .replace(brackets(/\\\\{/g), '\\uFFF0')\n      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\n    // split string to expression and non-expresion parts\n    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\n    return new Function('d', 'return ' + (\n\n      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n      !p[0] && !p[2] && !p[3]\n\n        // if expression, evaluate it\n        ? expr(p[1])\n\n        // if template, evaluate all expressions in it\n        : '[' + p.map(function(s, i) {\n\n            // is it an expression or a string (every second part is an expression)\n          return i % 2\n\n              // evaluate the expressions\n              ? expr(s, true)\n\n              // process string parts of the template:\n              : '\"' + s\n\n                  // preserve new lines\n                  .replace(/\\n/g, '\\\\n')\n\n                  // escape quotes\n                  .replace(/\"/g, '\\\\\"')\n\n                + '\"'\n\n        }).join(',') + '].join(\"\")'\n      )\n\n      // bring escaped { and } back\n      .replace(/\\uFFF0/g, brackets(0))\n      .replace(/\\uFFF1/g, brackets(1))\n\n    + ';')\n\n  }\n\n\n  // parse { ... } expression\n\n  function expr(s, n) {\n    s = s\n\n      // convert new lines to spaces\n      .replace(/\\n/g, ' ')\n\n      // trim whitespace, brackets, strip comments\n      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\n    // is it an object literal? i.e. { key : value }\n    return /^\\s*[\\w- \"']+ *:/.test(s)\n\n      // if object literal, return trueish keys\n      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n      ? '[' +\n\n          // extract key:val pairs, ignoring any nested objects\n          extract(s,\n\n              // name part: name:, \"name\":, 'name':, name :\n              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\n              // expression part: everything upto a comma followed by a name (see above) or end of line\n              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n              ).map(function(pair) {\n\n                // get key, val parts\n                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\n                  // wrap all conditional parts to ignore errors\n                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\n                })\n\n              }).join('')\n\n        + '].join(\" \").trim()'\n\n      // if js expression, evaluate as javascript\n      : wrap(s, n)\n\n  }\n\n\n  // execute js w/o breaking on errors or undefined vars\n\n  function wrap(s, nonull) {\n    s = s.trim()\n    return !s ? '' : '(function(v){try{v='\n\n        // prefix vars (name => data.name)\n        + (s.replace(reVars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })\n\n          // break the expression if its empty (resulting in undefined value)\n          || 'x')\n      + '}catch(e){'\n      + '}finally{return '\n\n        // default to empty string for falsy values except zero\n        + (nonull === true ? '!v&&v!==0?\"\":v' : 'v')\n\n      + '}}).call(d)'\n  }\n\n\n  // split string by an array of substrings\n\n  function split(str, substrings) {\n    var parts = []\n    substrings.map(function(sub, i) {\n\n      // push matched expression and part before it\n      i = str.indexOf(sub)\n      parts.push(str.slice(0, i), sub)\n      str = str.slice(i + sub.length)\n    })\n\n    // push the remaining part\n    return parts.concat(str)\n  }\n\n\n  // match strings between opening and closing regexp, skipping any inner/nested matches\n\n  function extract(str, open, close) {\n\n    var start,\n        level = 0,\n        matches = [],\n        re = new RegExp('('+open.source+')|('+close.source+')', 'g')\n\n    str.replace(re, function(_, open, close, pos) {\n\n      // if outer inner bracket, mark position\n      if (!level && open) start = pos\n\n      // in(de)crease bracket level\n      level += open ? 1 : -1\n\n      // if outer closing bracket, grab the match\n      if (!level && close != null) matches.push(str.slice(start, pos+close.length))\n\n    })\n\n    return matches\n  }\n\n})()\n\n// { key, i in items} -> { key, i, items }\nfunction loopKeys(expr) {\n  var b0 = brackets(0),\n      els = expr.slice(b0.length).match(/^\\s*(\\S+?)\\s*(?:,\\s*(\\S+))?\\s+in\\s+(.+)$/)\n  return els ? { key: els[1], pos: els[2], val: b0 + els[3] } : { val: expr }\n}\n\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n\n/* Beware: heavy stuff */\nfunction _each(dom, parent, expr) {\n\n  remAttr(dom, 'each')\n\n  var tagName = getTagName(dom),\n      template = dom.outerHTML,\n      hasImpl = !!tagImpl[tagName],\n      impl = tagImpl[tagName] || {\n        tmpl: template\n      },\n      root = dom.parentNode,\n      placeholder = document.createComment('riot placeholder'),\n      tags = [],\n      child = getTag(dom),\n      checksum\n\n  root.insertBefore(placeholder, dom)\n\n  expr = loopKeys(expr)\n\n  // clean template code\n  parent\n    .one('premount', function () {\n      if (root.stub) root = parent.root\n      // remove the original DOM node\n      dom.parentNode.removeChild(dom)\n    })\n    .on('update', function () {\n      var items = tmpl(expr.val, parent)\n\n      // object loop. any changes cause full redraw\n      if (!isArray(items)) {\n\n        checksum = items ? JSON.stringify(items) : ''\n\n        items = !items ? [] :\n          Object.keys(items).map(function (key) {\n            return mkitem(expr, key, items[key])\n          })\n      }\n\n      var frag = document.createDocumentFragment(),\n          i = tags.length,\n          j = items.length\n\n      // unmount leftover items\n      while (i > j) {\n        tags[--i].unmount()\n        tags.splice(i, 1)\n      }\n\n      for (i = 0; i < j; ++i) {\n        var _item = !checksum && !!expr.key ? mkitem(expr, items[i], i) : items[i]\n\n        if (!tags[i]) {\n          // mount new\n          (tags[i] = new Tag(impl, {\n              parent: parent,\n              isLoop: true,\n              hasImpl: hasImpl,\n              root: hasImpl ? dom.cloneNode() : root,\n              item: _item\n            }, dom.innerHTML)\n          ).mount()\n\n          frag.appendChild(tags[i].root)\n        } else\n          tags[i].update(_item)\n\n        tags[i]._item = _item\n\n      }\n\n      root.insertBefore(frag, placeholder)\n\n      if (child) parent.tags[tagName] = tags\n\n    }).one('updated', function() {\n      var keys = Object.keys(parent)// only set new values\n      walk(root, function(node) {\n        // only set element node and not isLoop\n        if (node.nodeType == 1 && !node.isLoop && !node._looped) {\n          node._visited = false // reset _visited for loop node\n          node._looped = true // avoid set multiple each\n          setNamed(node, parent, keys)\n        }\n      })\n    })\n\n}\n\n\nfunction parseNamedElements(root, parent, childTags) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || dom.getAttribute('each')) ? 1 : 0\n\n      // custom child tag\n      var child = getTag(dom)\n\n      if (child && !dom.isLoop) {\n        var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),\n            tagName = getTagName(dom),\n            ptag = parent,\n            cachedTag\n\n        while (!getTag(ptag.root)) {\n          if (!ptag.parent) break\n          ptag = ptag.parent\n        }\n\n        // fix for the parent attribute in the looped elements\n        tag.parent = ptag\n\n        cachedTag = ptag.tags[tagName]\n\n        // if there are multiple children tags having the same name\n        if (cachedTag) {\n          // if the parent tags property is not yet an array\n          // create it adding the first cached tag\n          if (!isArray(cachedTag))\n            ptag.tags[tagName] = [cachedTag]\n          // add the new nested tag to the array\n          ptag.tags[tagName].push(tag)\n        } else {\n          ptag.tags[tagName] = tag\n        }\n\n        // empty the child node once we got its template\n        // to avoid that its children get compiled multiple times\n        dom.innerHTML = ''\n        childTags.push(tag)\n      }\n\n      if (!dom.isLoop)\n        setNamed(dom, parent, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (val.indexOf(brackets(0)) >= 0) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = dom.getAttribute('each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n      opts = inherit(conf.opts) || {},\n      dom = mkdom(impl.tmpl),\n      parent = conf.parent,\n      isLoop = conf.isLoop,\n      hasImpl = conf.hasImpl,\n      item = cleanUpData(conf.item),\n      expressions = [],\n      childTags = [],\n      root = conf.root,\n      fn = impl.fn,\n      tagName = root.tagName.toLowerCase(),\n      attr = {},\n      propsInSyncWithParent = [],\n      loopDom,\n      TAG_ATTRIBUTES = /([\\w\\-]+)\\s?=\\s?['\"]([^'\"]+)[\"']/gim\n\n\n  if (fn && root._tag) {\n    root._tag.unmount(true)\n  }\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  if (impl.attrs) {\n    var attrs = impl.attrs.match(TAG_ATTRIBUTES)\n\n    each(attrs, function(a) {\n      var kv = a.split(/\\s?=\\s?/)\n      root.setAttribute(kv[0], kv[1].replace(/['\"]/g, ''))\n    })\n\n  }\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  this._id = fastAbs(~~(new Date().getTime() * Math.random()))\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (brackets(/\\{.*\\}/).test(val)) attr[el.name] = val\n  })\n\n  if (dom.innerHTML && !/select|select|optgroup|tbody|tr/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      opts[el.name] = tmpl(el.value, ctx)\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[name] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF)\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = ~propsInSyncWithParent.indexOf(k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  this.update = function(data) {\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (typeof item === T_OBJECT || isArray(item)) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n    self.trigger('updated')\n  }\n\n  this.mixin = function() {\n    each(arguments, function(mix) {\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n      each(Object.keys(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(mix[key]) ? mix[key].bind(self) : mix[key]\n      })\n      // init method will be called automatically\n      if (mix.init) mix.init.bind(self)()\n    })\n  }\n\n  this.mount = function() {\n\n    updateOpts()\n\n    // initialiation\n    fn && fn.call(self, opts)\n\n    toggle(true)\n\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n    if (!self.parent || hasImpl) parseExpressions(self.root, self, expressions) // top level before update, empty root\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('premount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      self.root = root = loopDom = dom.firstChild\n\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) self.root = root = parent.root\n    }\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  }\n\n\n  this.unmount = function(keepRootTag) {\n    var el = loopDom || root,\n        p = el.parentNode\n\n    if (p) {\n\n      if (parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(parent.tags[tagName]))\n          each(parent.tags[tagName], function(tag, i) {\n            if (tag._id == self._id)\n              parent.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          parent.tags[tagName] = undefined\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n\n      // the loop tags will be always in sync with the parent automatically\n      if (isLoop)\n        parent[evt]('unmount', self.unmount)\n      else\n        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n\n}\n\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var item = tag._item,\n        ptag = tag.parent\n\n    if (!item)\n      while (ptag) {\n        item = ptag._item\n        ptag = item ? false : ptag.parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // ignore error on some browsers\n    try {\n      e.currentTarget = dom\n      if (!e.target) e.target = e.srcElement\n      if (!e.which) e.which = e.charCode || e.keyCode\n    } catch (ignored) { '' }\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      e.preventDefault && e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      var el = item ? tag.parent : tag\n      el.update()\n    }\n\n  }\n\n}\n\n// used by if- attribute\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n        attrName = expr.attr,\n        value = tmpl(expr.expr, tag),\n        parent = expr.dom.parentNode\n\n    if (value == null) value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) return dom.nodeValue = value.toString()\n\n    // remove original attribute\n    remAttr(dom, attrName)\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          insertTo(stub.parentNode, stub, dom)\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        insertTo(dom.parentNode, dom, stub)\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (attrName.slice(0, 5) == 'riot-' && attrName != 'riot-tag') {\n      attrName = attrName.slice(5)\n      value ? dom.setAttribute(attrName, value) : remAttr(dom, attrName)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n        value = attrName\n      }\n\n      if (typeof value !== T_OBJECT) dom.setAttribute(attrName, value)\n\n    }\n\n  })\n\n}\n\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\nfunction isFunction(v) {\n  return typeof v === 'function' || false   // avoid IE problems\n}\n\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\nfunction fastAbs(nr) {\n  return (nr ^ (nr >> 31)) - (nr >> 31)\n}\n\nfunction getTag(dom) {\n  var tagName = dom.tagName.toLowerCase()\n  return tagImpl[dom.getAttribute(RIOT_TAG) || tagName]\n}\n\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = dom.getAttribute('name'),\n    tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if ((obj = args[i])) {\n      for (var key in obj) {      // eslint-disable-line guard-for-in\n        src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n// with this function we avoid that the current Tag methods get overridden\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag)) return data\n\n  var o = {},\n      blackList = ['update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isloop', 'tags', 'parent', 'opts']\n  for (var key in data) {\n    if (!~blackList.indexOf(key))\n      o[key] = data[key]\n  }\n  return o\n}\n\nfunction mkdom(template) {\n  var checkie = ieVersion && ieVersion < 10,\n      matches = /^\\s*<([\\w-]+)/.exec(template),\n      tagName = matches ? matches[1].toLowerCase() : '',\n      rootTag = (tagName === 'th' || tagName === 'td') ? 'tr' :\n                (tagName === 'tr' ? 'tbody' : 'div'),\n      el = mkEl(rootTag)\n\n  el.stub = true\n\n  if (checkie) {\n    if (tagName === 'optgroup')\n      optgroupInnerHTML(el, template)\n    else if (tagName === 'option')\n      optionInnerHTML(el, template)\n    else if (rootTag !== 'div')\n      tbodyInnerHTML(el, template, tagName)\n    else\n      checkie = 0\n  }\n  if (!checkie) el.innerHTML = template\n\n  return el\n}\n\nfunction walk(dom, fn) {\n  if (dom) {\n    if (fn(dom) === false) walk(dom.nextSibling, fn)\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\nfunction replaceYield (tmpl, innerHTML) {\n  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gim, innerHTML || '')\n}\n\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\nfunction setNamed(dom, parent, keys) {\n  each(dom.attributes, function(attr) {\n    if (dom._visited) return\n    if (attr.name === 'id' || attr.name === 'name') {\n      dom._visited = true\n      var p, v = attr.value\n      if (~keys.indexOf(v)) return\n\n      p = parent[v]\n      if (!p)\n        parent[v] = dom\n      else\n        isArray(p) ? p.push(dom) : (parent[v] = [p, dom])\n    }\n  })\n}\n/**\n *\n * Hacks needed for the old internet explorer versions [lower than IE10]\n *\n */\n/* istanbul ignore next */\nfunction tbodyInnerHTML(el, html, tagName) {\n  var div = mkEl('div'),\n      loops = /td|th/.test(tagName) ? 3 : 2,\n      child\n\n  div.innerHTML = '<table>' + html + '</table>'\n  child = div.firstChild\n\n  while (loops--) child = child.firstChild\n\n  el.appendChild(child)\n\n}\n/* istanbul ignore next */\nfunction optionInnerHTML(el, html) {\n  var opt = mkEl('option'),\n      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n      eachRegx = /each=[\\\"'](.+?)[\\\"']/,\n      ifRegx = /if=[\\\"'](.+?)[\\\"']/,\n      innerRegx = />([^<]*)</,\n      valuesMatch = html.match(valRegx),\n      selectedMatch = html.match(selRegx),\n      innerValue = html.match(innerRegx),\n      eachMatch = html.match(eachRegx),\n      ifMatch = html.match(ifRegx)\n\n  if (innerValue) opt.innerHTML = innerValue[1]\n  else opt.innerHTML = html\n\n  if (valuesMatch) opt.value = valuesMatch[1]\n  if (selectedMatch) opt.setAttribute('riot-selected', selectedMatch[1])\n  if (eachMatch) opt.setAttribute('each', eachMatch[1])\n  if (ifMatch) opt.setAttribute('if', ifMatch[1])\n\n  el.appendChild(opt)\n}\n/* istanbul ignore next */\nfunction optgroupInnerHTML(el, html) {\n  var opt = mkEl('optgroup'),\n      labelRegx = /label=[\\\"'](.+?)[\\\"']/,\n      elementRegx = /^<([^>]*)>/,\n      tagRegx = /^<([^ \\>]*)/,\n      labelMatch = html.match(labelRegx),\n      elementMatch = html.match(elementRegx),\n      tagMatch = html.match(tagRegx),\n      innerContent = html\n\n  if (elementMatch) {\n    var options = html.slice(elementMatch[1].length+2, -tagMatch[1].length-3).trim()\n    innerContent = options\n  }\n\n  if (labelMatch) opt.setAttribute('riot-label', labelMatch[1])\n\n  if (innerContent) {\n    var innerOpt = mkEl('div')\n\n    optionInnerHTML(innerOpt, innerContent)\n\n    opt.appendChild(innerOpt.firstChild)\n  }\n\n  el.appendChild(opt)\n}\n\n/*\n Virtual dom is an array of custom tags on the document.\n Updates and unmounts propagate downwards from parent to children.\n*/\n\nvar virtualDom = [],\n    tagImpl = {},\n    styleNode\n\nvar RIOT_TAG = 'riot-tag'\n\nfunction injectStyle(css) {\n\n  styleNode = styleNode || mkEl('style')\n\n  if (!document.head) return\n\n  if (styleNode.styleSheet)\n    styleNode.styleSheet.cssText += css\n  else\n    styleNode.innerHTML += css\n\n  if (!styleNode._rendered)\n    if (styleNode.styleSheet) {\n      document.body.appendChild(styleNode)\n    } else {\n      var rs = $('style[type=riot]')\n      if (rs) {\n        rs.parentNode.insertBefore(styleNode, rs)\n        rs.parentNode.removeChild(rs)\n      } else document.head.appendChild(styleNode)\n\n    }\n\n  styleNode._rendered = true\n\n}\n\nfunction mountTo(root, tagName, opts) {\n  var tag = tagImpl[tagName],\n      // cache the inner HTML to fix #855\n      innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    virtualDom.push(tag)\n    return tag.on('unmount', function() {\n      virtualDom.splice(virtualDom.indexOf(tag), 1)\n    })\n  }\n\n}\n\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else injectStyle(css)\n  }\n  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n      allTags,\n      tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      list += ', *[riot-tag=\"'+ e.trim() + '\"]'\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    if (root.tagName) {\n      if (tagName && !root.getAttribute(RIOT_TAG))\n        root.setAttribute(RIOT_TAG, tagName)\n\n      var tag = mountTo(root,\n        tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    }\n    else if (root.length) {\n      each(root, pushTags)   // assume nodeList\n    }\n  }\n\n  // ----- mount code -----\n\n  if (typeof tagName === T_OBJECT) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(','))\n\n    els = $$(selector)\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  if (els.tagName)\n    pushTags(els)\n  else\n    each(els, pushTags)\n\n  return tags\n}\n\n// update everything\nriot.update = function() {\n  return each(virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n// @deprecated\nriot.mountTo = riot.mount\n\n\n  // share methods for other riot parts, e.g. compiler\n  riot.util = { brackets: brackets, tmpl: tmpl }\n\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return window.riot = riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : undefined);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","var _RiotControlApi = ['on','one','off','trigger']\nvar RiotControl = {\n  _stores: [],\n  addStore: function(store) {\n    this._stores.push(store)\n  }\n}\n_RiotControlApi.forEach(function(api){\n  RiotControl[api] = function() {\n    var args = [].slice.call(arguments)\n    this._stores.forEach(function(el){\n        el[api].apply(null, args)\n      })\n  }\n})\n\nmodule.exports = RiotControl;\n\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/riot.control.js\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/css-loader/lib/css-base.js\n ** module id = 3\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tvar head = getHeadElement();\r\n\tlinkElement.rel = \"stylesheet\";\r\n\thead.appendChild(linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement();\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/style-loader/addStyles.js\n ** module id = 4\n ** module chunks = 0\n **/","export default function (opts) {\n  this.title = 'This is the best title';\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/entry/feat-x.ctrl.js\n **/","var control = require('riot.control');\nvar todoStore = require('components/todo/todo.store');\n\ncontrol.addStore(todoStore);\nriot.tag ('feat-x',\n  require('components/entry/feat-x.tpl.html'),\n  require('components/entry/feat-x.style'),\n  require('components/entry/feat-x.ctrl'));\nriot.mount('feat-x');\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/entry/index.js\n **/","riot.tag ('messenger',\n  require('components/messenger/messenger.tpl'),\n  require('components/messenger/messenger.style'),\n  require('components/messenger/messenger.ctrl'));\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/messenger/index.js\n **/","var control = require('riot.control');\nexport default function (opts) {\n  this.count = 0;\n  control.on('change', items => {\n    this.count = items.length;\n    this.update();\n  });\n  control.on('todo_add', item => {\n    this.count +=1 ;\n    this.thing = item.title;\n    this.update();\n  });\n  control.on('todo_remove', () => {\n    this.count -= 1;\n    this.update();\n  });\n\n  this.send = (e) => {\n    var msg = this.message.value;\n    control.trigger('msg_sent', {\n      msg: this.message.value\n    });\n    this.message.value = '';\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/messenger/messenger.ctrl.js\n **/","riot.tag ('todo',\n  require('components/todo/todo.tpl'),\n  require('components/todo/todo.style'),\n  require('components/todo/todo.ctrl'));\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/todo/index.js\n **/","var control = require('riot.control');\nexport default function (opts) {\n  this.on('mount', () => { control.trigger('todo_init') });\n  control.on('change', items => { this.items = items; this.update(); } );\n\n  this.disabled = true;\n  this.items = [];\n\n  this.edit = e => { this.text = e.target.value; };\n  this.add = e => {\n    if (this.text) {\n      control.trigger('todo_add', { title: this.text });\n      this.text = this.input.value = '';\n    }\n  };\n  this.toggle = e => {\n    var item = e.item;\n    item.done = !item.done;\n    return true;\n  };\n  this.remove = e => { control.trigger('todo_remove'); };\n\n  control.on('msg_sent', msg => {\n    this.msg = msg.msg;\n    this.update();\n  });\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/todo/todo.ctrl.js\n **/","// TodoStore definition.\n// Flux stores house application logic and state that relate to a specific domain.\n// In this case, a list of todo items.\n\nfunction TodoStore() {\n  var store = riot.observable(this); // event emitter\n  this.todos = [\n    { title: 'Task 1', done: false },\n    { title: 'Task 2', done: false }\n  ];\n\n  this.stuff = [\n    { title: 'tt', done: false },\n    { title: 'tt', done: false }\n  ];\n\n  this.listen = (e, fn, d, bn) => {\n    var self = this;\n    var config = {model: d, triggerName: bn ? bn : 'change'};\n    var broadcast = () => { self.trigger(config.triggerName, config.model); };\n    if (typeof fn === 'function') {\n      self.on(e, fn);\n      broadcast();\n    } else {\n      self.on(e, () => { broadcast(); });\n    }\n  };\n\n  this.listen('todo_init', 'broadcast', this.stuff);\n\n  this.listen('todo_add', newTodo => {\n    this.stuff.push(newTodo);\n  });\n\n  this.listen('todo_remove', () => {\n    this.stuff.pop();\n  });\n\n  return store;\n  // The store emits change events to any listening views, so that they may react and redraw themselves.\n\n}\n\nmodule.exports = new TodoStore;\n\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/todo/todo.store.js\n **/","riot.tag ('widget',\n  require('components/widget/widget.tpl'),\n  require('components/widget/widget.style'),\n  require('components/widget/widget.ctrl'));\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/widget/index.js\n **/","var control = require('riot.control');\nexport default function (opts) {\n  control.on('msg_sent', msg => {\n    this.msg = msg.msg;\n    this.update();\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/components/widget/widget.ctrl.js\n **/","require('components/widget');\nrequire('components/todo');\nrequire('components/messenger');\nrequire('components/entry');\n\n\n/** WEBPACK FOOTER **\n ** ./feature-x/index.js\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"todo-app{display:block;border:1px solid #ccc;padding:20px}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/css-loader!../~/sass-loader!./feature-x/components/entry/feat-x.style.scss\n ** module id = 15\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"messenger button{background-color:#fff;border:none;border:1px solid #ccc;padding:10px 20px}messenger input{padding:10px}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/css-loader!../~/sass-loader!./feature-x/components/messenger/messenger.style.scss\n ** module id = 16\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"todo button{background-color:#1fadc5;border:1px solid rgba(0,0,0,.2);font-size:100%;color:#fff;padding:.6em 1.2em;border-radius:3em;cursor:pointer;margin:0 .3em;outline:0}todo button[disabled]{background-color:#ddd;color:#aaa}todo input{font-size:100%;padding:.6em;border:1px solid #ccc;border-radius:3px}todo .completed{text-decoration:line-through;color:#ccc}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/css-loader!../~/sass-loader!./feature-x/components/todo/todo.style.scss\n ** module id = 17\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/css-loader!../~/sass-loader!./feature-x/components/widget/widget.style.scss\n ** module id = 18\n ** module chunks = 0\n **/","module.exports = \"<h2>\\n<messenger></messenger>\\n  <todo></todo>\\n\\n  <widget></widget>\\n</h2>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./feature-x/components/entry/feat-x.tpl.html\n ** module id = 19\n ** module chunks = 0\n **/","module.exports = \"<p>this is the observer: count: { count }, added: { thing }</p>\\n\\n<form onsubmit=\\\"{ send }\\\">\\n  <input name=\\\"message\\\" onkeyup=\\\"{ edit }\\\">\\n  <button> send msg </button>\\n</form>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./feature-x/components/messenger/messenger.tpl.html\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = \"<p>message:  { msg } </p>\\n<ul>\\n  <li each=\\\"{ items }\\\">\\n    <label class=\\\"{ completed: done }\\\">\\n      <input type=\\\"checkbox\\\" __checked=\\\"{ done }\\\" onclick=\\\"{ parent.toggle }\\\"> { title }\\n    </label>\\n  </li>\\n</ul>\\n<form onsubmit=\\\"{ add }\\\">\\n  <input name=\\\"input\\\" oninput=\\\"{ edit }\\\">\\n  <button __disabled=\\\"{ !text }\\\">Add #{ items.length + 1 }</button>\\n</form>\\n<button __disabled=\\\"{ !items.length }\\\" onclick=\\\"{ remove }\\\">Remove</button>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./feature-x/components/todo/todo.tpl.html\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = \"  <p><strong>this is the widget and listening for messages { msg }</strong></p>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./feature-x/components/widget/widget.tpl.html\n ** module id = 22\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./feat-x.style.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./feat-x.style.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./feat-x.style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./feature-x/components/entry/feat-x.style.scss\n ** module id = 23\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./messenger.style.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./messenger.style.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./messenger.style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./feature-x/components/messenger/messenger.style.scss\n ** module id = 24\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./todo.style.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./todo.style.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./todo.style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./feature-x/components/todo/todo.style.scss\n ** module id = 25\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./widget.style.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./widget.style.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/sass-loader/index.js!./widget.style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./feature-x/components/widget/widget.style.scss\n ** module id = 26\n ** module chunks = 0\n **/"],"sourceRoot":""}